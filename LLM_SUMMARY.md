# Upcount — LLM-readable Summary

This file provides a compact, machine- and LLM-friendly summary of the Upcount project (local-first invoicing & time-tracking desktop app).

## Repo at-a-glance

- Name: Upcount
- Purpose: Offline-first invoicing, clients, projects, time-tracking (desktop app)
- Tech stack: Frontend: React 18 + TypeScript + Vite + Ant Design; State: Jotai; i18n: Lingui; PDF: react-pdf
- Desktop shell / backend: Tauri (Rust) using `sqlx` + SQLite for local storage
- Migrations: SQL files in `migrations/` (numbered, incremental)

## Important files

- Frontend entry: [src/main.tsx](src/main.tsx)
- Frontend root: [src/app.tsx](src/app.tsx)
- Main layout: [src/layouts/base.tsx](src/layouts/base.tsx)
- Routes: [src/routes](src/routes)
- State atoms (Jotai): [src/atoms](src/atoms) (re-exports in `src/atoms/index.ts`)
- Utilities: [src/utils](src/utils)
- Styles: [src/styles/base.scss](src/styles/base.scss)
- Rust backend crate: [src-tauri/Cargo.toml](src-tauri/Cargo.toml)
- Rust entry: [src-tauri/src/main.rs](src-tauri/src/main.rs)
- DB module: [src-tauri/src/db.rs](src-tauri/src/db.rs) and `src-tauri/src/db/` submodules
- Tauri commands: [src-tauri/src/commands.rs](src-tauri/src/commands.rs)
- SQL migrations: [migrations/](migrations)

## Architecture summary (concise)

- Single repository with two main parts:
  - Frontend web UI built with React, bundled by Vite, runs inside Tauri's webview.
  - Native backend (Rust) exposing application commands via Tauri (SQLite access, file-system, process, updater, etc.).

- Data flow (common operations):
  1. UI reads/writes state via Jotai atoms in `src/atoms/*`.
  2. Atoms call Tauri commands using `invoke(...)` to interact with the Rust backend (examples: `get_organizations`, `create_organization`, `update_organization`, `delete_organization`).
  3. Rust backend uses `sqlx` to run queries and migrations against a local SQLite database (created if missing).
  4. Migrations are applied on startup from the `migrations` folder (embedded via `sqlx::migrate!`).

## Runtime & dev commands

- Frontend development (hot reload): `npm run dev` (runs Vite). Tauri dev flow typically uses `tauri dev` (Tauri CLI is a dependency).
- Build web assets: `npm run build` (runs `tsc && vite build`).
- Build desktop app: use the Tauri CLI / cargo via `cargo tauri build` or provided scripts (not in `package.json` by default).

## Key design notes useful for an LLM or code-assisted task

- UI routing: `react-router` defined in `src/app.tsx` — main routes: `/invoices`, `/clients`, `/projects`, `/time-tracking`, `/settings`.
- Local-first: app expects a local SQLite DB and uses Tauri plugins for file, process, updater, HTTP, etc.
- State: Jotai atoms wrap async Tauri invocations (see `src/atoms/organization.ts` for pattern examples). Atoms often expose read/write and call `setOrganizationsAtom` to refresh lists.
- Binary assets: Organization logos are passed as byte arrays (Vec<u8>) between frontend and Rust (frontend encodes data URL -> byte array, backend stores as blob).

## Where to look for specific tasks

- Add a new Tauri command: `src-tauri/src/commands.rs` + export in `lib.rs`.
- Change DB schema: add/modify SQL in `migrations/` and update `src-tauri/src/db/*.rs` code.
- Modify UI route or views: `src/routes/*` and `src/layouts/base.tsx`.
- Update translations: `src/locales/*.po` and run `npm run extract` (lingui).

## Minimal pointers for automated analysis / LLM agents

- Use `src/atoms/*` to map UI features to backend commands (invoke names).
- Use `migrations/` to understand table schemas and evolution.
- Use `src-tauri/src/db.rs` and submodules to map SQL operations to Rust function names and exported types.
- Entry points: `src/main.tsx` -> `src/app.tsx` (frontend), `src-tauri/src/main.rs` -> `upcount_lib::run()` (Rust).

## Next recommended actions

- (Human) confirm preferred filename/location for this summary or request more detail for any area.
- (Automated) I can expand this into a deeper, annotated map linking UI components -> atoms -> Tauri commands -> SQL statements for LLM consumption.

---
Generated by an automated code walkthrough on project root.
